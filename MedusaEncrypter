package mainpackage;

import java.nio.charset.StandardCharsets;

// IMPORTANT NOTES [!]
// byte UTF-8 range encryption should be within the STRICT range of [33, 126] decimal, [21, 7e] hexadecimal
// This is because those are the only chars that are not kinda weird, with unexpected behavior and overall, the only ones that use just 1 byte.
// Check this link to see which chars you can use https://www.utf8-chartable.de/
// Do not use chars out of range on the plainText

public class MedusaEncrypter {

	public static String encrypt(String plain, String key) {

		return null;
	}

	public static String decrypt(String encrypted, String key) {

		return null;
	}

	public static String forgeLoad(String text, String load) {

		int loadFittings = (int) Math.floor((double) text.length() / (double) load.length());
		int loadSpare = text.length() % load.length();
		String forgedLoad = "";

		// Adds the fitting loads
		// If the load does not fit at all, this loop is ignored
		for (int i = 0; i < loadFittings; i++) {
			forgedLoad += load;
		}

		// load needs to be trimmed and pushed once
		if (loadSpare != 0) {
			forgedLoad += trimAndPush(load, loadSpare);
		}

		return forgedLoad;

	}

	public static String buildBytes(byte[] bytes) {
		return new String(bytes, StandardCharsets.UTF_8);
	}

	// requestedLength should be different to the chain length
	public static String trimAndPush(String chain, int requestedLength) {

		// Stack: The substring of the requested length
		// Payload: The part that is not the stack
		String stack = chain.substring(0, requestedLength);
		String payload = chain.substring(stack.length(), chain.length());

		byte[] stackBytes = stack.getBytes();
		final byte[] payloadBytes = payload.getBytes();

		// This variable is used to determine how many iterations the for loop should
		// give. It is initialized to the length of the stack if the stack and payload
		// happen to be the same length, this way there is no need to assign the length
		// again, since they are both equal
		int counterReference = stack.length();
		byte power = 0; // 0: equal, 1: stack, 2: payload

		if (stack.length() > payload.length()) {
			counterReference = stack.length();
			power = 1;
		}

		if (stack.length() < payload.length()) {
			counterReference = payload.length();
			power = 2;
		}

		int pointer = 0;
		if (power == 1 || power == 0) {

			// Pointer for the payload, iterator for the stack
			for (int i = 0; i < counterReference; i++) {

				if (stackBytes[i] + payloadBytes[pointer] > 126) {

					stackBytes[i] += (payloadBytes[pointer] - 126);

					if (stackBytes[i] < 33) {
						stackBytes[i] += 32;
					}

				} else {
					stackBytes[i] += payloadBytes[pointer];
				}

				if (pointer == payload.length() - 1) {
					pointer = 0;
				} else {
					pointer++;
				}
			}

		} else {

			// Pointer for the stack, iterator for the payload
			for (int i = 0; i < counterReference; i++) {

				if (stackBytes[pointer] + payloadBytes[i] > 126) {

					stackBytes[pointer] += (payloadBytes[i] - 126);

					if (stackBytes[pointer] < 33) {
						stackBytes[pointer] += 32;
					}

				} else {

					stackBytes[pointer] += payloadBytes[i];
				}

				if (pointer == stack.length() - 1) {
					pointer = 0;
				} else {
					pointer++;
				}
			}
		}

		String newStack = "";
		for (byte b : stackBytes) {
			newStack += (char) b;
		}

		return newStack;
	}

}
