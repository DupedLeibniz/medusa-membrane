package mainpackage;

import java.nio.charset.StandardCharsets;

// IMPORTANT NOTES [!]
// byte UTF-8 range encryption should be within the STRICT range of [32, 126]
// This is because those are the only chars that are not kind of weird, with unexpected behavior and overall, the only ones that use just 1 byte.
// Check this link to see which chars you can use: https://www.utf8-chartable.de/

public class MedusaEncrypter {

	public static String encrypt(String plain, String key) throws BannedCharException {

		if (hasBannedChars(plain)) {
			throw new BannedCharException("One or more banned chars in the plain text");
		}

		if (hasBannedChars(key)) {
			throw new BannedCharException("One or more banned chars in the key");
		}

		String load = forgeLoad(plain, key);
		byte[] bytes = new byte[plain.length()];

		for (int i = 0; i < plain.length(); i++) {
			bytes[i] = shiftParallelBytes(plain.charAt(i), load.charAt(i), true);
		}

		return buildBytes(bytes);
	}

	public static String decrypt(String encrypted, String key) throws BannedCharException {

		if (hasBannedChars(encrypted)) {
			throw new BannedCharException("One or more banned chars in the plain text");
		}

		if (hasBannedChars(key)) {
			throw new BannedCharException("One or more banned chars in the key");
		}

		String load = forgeLoad(encrypted, key);
		byte[] bytes = new byte[encrypted.length()];

		for (int i = 0; i < encrypted.length(); i++) {
			bytes[i] = shiftParallelBytes(encrypted.charAt(i), load.charAt(i), false);
		}

		String decrypted = "";

		for (byte b : bytes) {
			decrypted += (char) b;
		}

		return decrypted;
	}

	private static boolean hasBannedChars(String s) {

		byte[] bytes = s.getBytes();

		for (byte b : bytes) {
			if (b < 32 || b > 126) {
				return true;
			}
		}

		return false;
	}

	private static String forgeLoad(String text, String load) {

		int loadFittings = (int) Math.floor((double) text.length() / (double) load.length());
		int loadSpare = text.length() % load.length();
		String forgedLoad = "";

		// Adds the fitting loads
		// If the load does not fit at all, this loop is ignored
		for (int i = 0; i < loadFittings; i++) {
			forgedLoad += load;
		}

		// load needs to be trimmed and pushed once
		if (loadSpare != 0) {
			forgedLoad += trimAndPush(load, loadSpare);
		}

		return forgedLoad;

	}

	// Jails the bytes between the range [32, 126];
	private static byte shiftParallelBytes(char char1, char char2, boolean operation) {

		final byte infLim = 32;
		final byte supLim = 126;

		final byte max = (supLim + 1) - infLim;

		final byte start = ("" + char1).getBytes()[0];
		byte steps = ("" + char2).getBytes()[0];

		byte end = -1;

		// +
		if (operation == true) {

			if (start + steps > supLim) {
				byte spare = (byte) (supLim - start);
				steps -= spare;

				boolean repeat = true;
				while (repeat) {
					if ((infLim - 1) + steps > supLim) {
						steps -= max;
					} else {
						repeat = false;
					}
				}

				end = (byte) ((infLim - 1) + steps);

			} else {
				end = (byte) (start + steps);
			}

		}

		// -
		if (operation == false) {

			if (start - steps < infLim) {

				byte spare = (byte) (start - infLim);
				steps -= spare;

				boolean repeat = true;
				while (repeat) {
					if ((supLim + 1) - steps < infLim) {
						steps -= max;
					} else {
						repeat = false;
					}
				}

				end = (byte) ((supLim + 1) - steps);

			} else {
				end = (byte) (start - steps);
			}

		}

		return end;

	}

	private static String buildBytes(byte[] bytes) {
		return new String(bytes, StandardCharsets.UTF_8);
	}

	private static String trimAndPush(String text, int requestedLength) {

		// Stack: The substring of the requested length
		// Payload: The part that is not the stack
		String stack = text.substring(0, requestedLength);
		String payload = text.substring(stack.length(), text.length());

		byte[] stackBytes = stack.getBytes();
		final byte[] payloadBytes = payload.getBytes();

		// This variable is used to determine how many iterations the for loop should
		// give. It is initialized to the length of the stack if the stack and payload
		// happen to be the same length, this way there is no need to assign the length
		// again, since they are both equal
		int counterReference = stack.length();
		byte power = 0; // 0: equal, 1: stack, 2: payload

		if (stack.length() > payload.length()) {
			counterReference = stack.length();
			power = 1;
		}

		if (stack.length() < payload.length()) {
			counterReference = payload.length();
			power = 2;
		}

		int pointer = 0;
		if (power == 1 || power == 0) {

			// Pointer for the payload, iterator for the stack
			for (int i = 0; i < counterReference; i++) {

				stackBytes[i] = shiftParallelBytes((char) stackBytes[i], (char) payloadBytes[pointer], true);

				if (pointer == payload.length() - 1) {
					pointer = 0;
				} else {
					pointer++;
				}
			}

		} else

		{

			// Pointer for the stack, iterator for the payload
			for (int i = 0; i < counterReference; i++) {

				stackBytes[pointer] = shiftParallelBytes((char) stackBytes[pointer], (char) payloadBytes[i], true);

				if (pointer == stack.length() - 1) {
					pointer = 0;
				} else {
					pointer++;
				}
			}
		}

		return buildBytes(stackBytes);
	}

	public static class BannedCharException extends Exception {

		public BannedCharException(String errorMessage) {
			super(errorMessage);
		}

	}

}
